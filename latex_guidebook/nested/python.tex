\section{Python}

\textcolor{green}{TODO: overview}

\textcolor{blue}{This section will not teach you everything you need to know to be python programmer. Rather, this section will assume you have programming experience and will focus on a few of the components of python that may be frequently encountered and may benefit from further explanation and examples.}

\subsection{Datatypes}

\subsubsection{Tuple}

\textcolor{blue}{fixed-length immutable sequence of Python objects.}

\subsubsection{List}

\textcolor{blue}{variable-length mutable sequence of Python objects.}

\paragraph{List Comprehensions}

\textcolor{blue}{para about list comprehensions}

% {{{py_nested_listcomp}}}
\begin{lstlisting}[style=pyInStyle]
matrix = [[1,2,3], [4,5,6], [7,8,9]]
# value is multiple of 3 and array sum >= 10
filtered = [[x for x in row if x % 3 == 0]
            for row in matrix if sum(row) >= 10]
print(filtered)
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
[[6], [9]]
\end{lstlisting}
\begin{markdown}
Using nested list comprehensions is possible but gets a little messy -- the rule of thumb is to not use more than 2 expressions in list comprehensions
\end{markdown}

\paragraph{Append Vs Extend}

\textcolor{blue}{Append vs extend.}

% {{{py_app_v_ext}}}
\begin{lstlisting}[style=pyInStyle]
x = [1, 2, 3]
x.append([4, 5])
print("Append: {}".format(x))

x = [1, 2, 3]
x.extend([4, 5])
print("Extend: {}".format(x))
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
Append: [1, 2, 3, [4, 5]]
Extend: [1, 2, 3, 4, 5]
\end{lstlisting}


\subsubsection{Dict}

\textcolor{blue}{para about dicts}

\subsubsection{Set}

\textcolor{blue}{para about sets}

\subsection{Functions}

\textcolor{blue}{para about functions}

\subsubsection{Keyword Only Arguments}

\textcolor{blue}{para about keyword only parameters}

% {{{py_func_kwonly}}}
\begin{lstlisting}[style=pyInStyle]
def func_with_kwargs(num, a, b,
                    *,
                    div_a=False,
                    div_b=False):
    if div_a:
        num /= a
    if div_b:
        num /= b
    return num

# print(func_with_kwargs(12, 2, 2, True, True)) # won't work
print(func_with_kwargs(12, 2, 2, div_a=True, div_b=True))
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
3.0
\end{lstlisting}
\begin{markdown}
all args after the `*` must be specified
\end{markdown}


\paragraph{Optional Parameters}

\textcolor{blue}{para about optional parameters}

% {{{py_opt_params}}}
\begin{lstlisting}[style=pyInStyle]
def log(message, *values):
    if not values:
        print(message)
    else:
        val_str = ", ".join(str(x) for x in values)
        print("{}: {}".format(message, val_str))

log("current number")
log("current numbers are", 1, 2)
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
current number
current numbers are: 1, 2
\end{lstlisting}

\subsubsection{Built-in Sequence Functions}

\paragraph{enumerate}

\textcolor{blue}{Enumerate is used for ...}

% {{{py_enumerate_01}}}
\begin{lstlisting}[style=pyInStyle]
for i, letter in enumerate(["a", "b", "c", "d"]):
    print("letter[{}]={}".format(i, letter))
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
letter[0]=a
letter[1]=b
letter[2]=c
letter[3]=d
\end{lstlisting}


% {{{py_enumerate_02}}}
\begin{lstlisting}[style=pyInStyle]
for i, letter in enumerate(["a", "b", "c", "d"], 1):
    print("letter#{}={}".format(i, letter))
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
letter #1=a
letter #2=b
letter #3=c
letter #4=d
\end{lstlisting}
\begin{markdown}
Using nested list comprehensions is possible but tgets a little messy -- the rule of thumb is to not use more than 2 expressions in list comprehensions
\end{markdown}


\paragraph{sorted}

\textcolor{blue}{para about sorted}

\paragraph{zip}

\textcolor{blue}{para about zip}

% {{{py_zip}}}
\begin{lstlisting}[style=pyInStyle]
pets = ["Siren", "Diesel"]
age = [3, 2]
for pet_info in zip(pets, age):
    print(pet_info)
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
('Siren', 3)
('Diesel', 2)
\end{lstlisting}

% {{{py_zip_longest}}}
\begin{lstlisting}[style=pyInStyle]
pets = ["Siren", "Diesel", "Bella"]
age = [3, 2]
print("---- Using zip")
for pet_info in zip(pets, age):
    print(pet_info)

print("------ using zip_longest")
for pet_info in zip_longest(pets, age):
    print(pet_info)
\end{lstlisting}
\begin{lstlisting}[style=pyOutStyle]
---- Using zip
('Siren', 3)
('Diesel', 2)
------ using zip_longest
('Siren', 3)
('Diesel', 2)
('Bella', None)
\end{lstlisting}

\paragraph{reversed}

\textcolor{blue}{para about reversed}

\subsection{Generators}

\textcolor{blue}{para about generators}

\subsection{Errors and Exception Handling}

\textcolor{blue}{para about errors and exception handling}

% {{{py_tryblock}}}
\begin{lstlisting}[style=pyInStyle]
try:
    # do something
except MyException as e:
    # handle exception
else:
    # runs when there are no exceptions
finally:
    # always runs after try:
\end{lstlisting}

\subsection{IO}

\textcolor{blue}{para about IO}

\subsection{Other}

\textcolor{blue}{para about other}


